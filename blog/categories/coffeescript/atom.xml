<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Coffeescript | Mustache :{]]></title>
  <link href="http://aanoaa.github.io/blog/categories/coffeescript/atom.xml" rel="self"/>
  <link href="http://aanoaa.github.io/"/>
  <updated>2017-04-28T00:30:41+09:00</updated>
  <id>http://aanoaa.github.io/</id>
  <author>
    <name><![CDATA[Hyungsuk Hong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Coffeescript-compile-args]]></title>
    <link href="http://aanoaa.github.io/blog/2013/12/20/coffeescript-compile-args/"/>
    <updated>2013-12-20T00:34:00+09:00</updated>
    <id>http://aanoaa.github.io/blog/2013/12/20/coffeescript-compile-args</id>
    <content type="html"><![CDATA[<pre><code>$ coffee -h

Usage: coffee [options] path/to/script.coffee -- [args]

If called without options, `coffee` will run your script.

  -b, --bare         compile without a top-level function wrapper
  -c, --compile      compile to JavaScript and save as .js files
  -e, --eval         pass a string from the command line as input
  -h, --help         display this help message
  -i, --interactive  run an interactive CoffeeScript REPL
  -j, --join         concatenate the source CoffeeScript before compiling
  -m, --map          generate source map and save as .map files
  -n, --nodes        print out the parse tree that the parser produces
      --nodejs       pass options directly to the "node" binary
  -o, --output       set the output directory for compiled JavaScript
  -p, --print        print out the compiled JavaScript
  -s, --stdio        listen for and compile scripts over stdio
  -l, --literate     treat stdio as literate style coffee-script
  -t, --tokens       print out the tokens that the lexer/rewriter produce
  -v, --version      display the version number
  -w, --watch        watch scripts for changes and rerun commands
</code></pre>

<p>javascript 는 html 의 script 로써만 사용하고 있습니다.
직접 사용하진 않고 <a href="http://coffeescript.org/">CoffeeScript</a> 를 쓰고
있습니다.</p>

<pre><code class="coffeescript">$ coffee -cps
$ -&gt;
  console.log 'oops'
&lt;Ctrl+d&gt;
// Generated by CoffeeScript 1.6.3
(function() {
  $(function() {
    return console.log('oops');
  });

}).call(this);
</code></pre>

<p>위 결과처럼 별 옵션없이 <code>--compile</code> 하면</p>

<pre><code>(function() { ... }).call(this)
</code></pre>

<p>무명함수로 감싼뒤에 실행합니다. lexical scope 이 자동으로 적용되어서
훌륭합니다만, 여러개의 파일을 하나의 html 에서 사용하고자 할때는 다른
파일에서 선언한 함수에 접근을 못하는 상황이 발생할 수 있습니다.</p>

<p>```html</p>

<script src="jquery.js"></script>


<script src="a.js"></script>


<script src="b.js"></script>


<pre><code>
`a.js` 에 `foo` 라는 함수를 만들어 놓고 `b.js` 에서 사용하고자 하면
못찾습니다.

    ReferenceError: foo is not defined

이를 해결하는 방법은 3가지가 있습니다. (더 있을 수도..)

1. requirejs 같은거 쓴다.

   `define`, `require` 으로 스슥

2. Window 이름공간을 더럽힌다.

   브라우저의 전역적 이름공간인 `Window` 의 프로토타입에 함수를
   추가해서 사용

3. 무명함수를 벗긴다.

   `coffee` 명령어의 `--bare` 옵션인데, `compile without a top-level
   function wrapper`
</code></pre>

<p>$ coffee -bcps
$ ->
  console.log &lsquo;oops&rsquo;
&lt;Ctrl+d>
// Generated by CoffeeScript 1.6.3
$(function() {
  return console.log(&lsquo;oops&rsquo;);
});
```
  요래 하는 것입니다.</p>

<hr />

<p>emacs 사용자라면 어찌 매번 컴파일하는 번거로운 작업을 한단 말입니까.
<code>coffee-cos-mode</code>(coffee compile-on-save mode) 에 컴파일 옵션을
수정해둬야 하겠습니다.</p>

<pre><code>(defun coffee-custom ()
  "coffee-mode-hook"
  (set (make-local-variable 'tab-width) 2)
  (setq coffee-args-compile '("-bc"))
)
</code></pre>
]]></content>
  </entry>
  
</feed>
